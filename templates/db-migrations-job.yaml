{{- if and .Values.supabase.enabled .Values.supabase.db.enabled (not .Values.externalPostgresql.enabled) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "kurrier.fullname" . }}-db-migrations
  labels:
    {{- include "kurrier.labels" . | nindent 4 }}
    app.kubernetes.io/component: db-migrations
  annotations:
    # Run after install/upgrade
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  ttlSecondsAfterFinished: 600
  backoffLimit: 3
  template:
    metadata:
      labels:
        {{- include "kurrier.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: db-migrations
    spec:
      restartPolicy: OnFailure
      {{- include "kurrier.imagePullSecrets" (dict "Values" .Values "componentPullSecrets" nil) | nindent 6 }}
      initContainers:
        # Wait for database to be ready
        - name: wait-for-db
          image: busybox:latest
          command:
            - sh
            - -c
            - |
              echo "Waiting for database to be ready..."
              until nc -z {{ include "kurrier.fullname" . }}-db 5432; do
                echo "Database not ready, waiting..."
                sleep 2
              done
              echo "Database is ready!"
      containers:
        - name: migrations
          image: "{{ .Values.supabase.db.image.repository }}:{{ .Values.supabase.db.image.tag }}"
          env:
            - name: PGHOST
              value: {{ include "kurrier.fullname" . }}-db
            - name: PGPORT
              value: "5432"
            - name: PGDATABASE
              value: {{ .Values.supabase.db.database | quote }}
            - name: PGUSER
              value: "postgres"
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "kurrier.postgresql.secretName" . }}
                  key: {{ include "kurrier.postgresql.secretKey" . }}
            - name: RLS_CLIENT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "kurrier.rls.secretName" . }}
                  key: {{ .Values.kurrier.rls.secretKey }}
          command:
            - bash
            - -c
            - |
              set -e
              echo "Running Kurrier database migrations..."

              # Wait for storage schema to exist (created by storage service)
              echo "Waiting for storage.buckets table..."
              for i in $(seq 1 60); do
                if psql -c "SELECT 1 FROM storage.buckets LIMIT 1" 2>/dev/null; then
                  echo "Storage schema ready!"
                  break
                fi
                echo "Waiting for storage schema... ($i/60)"
                sleep 2
              done

              # Create migrations tracking table
              psql -v ON_ERROR_STOP=1 <<-'EOSQL'
                CREATE TABLE IF NOT EXISTS public.migrations (
                  version TEXT PRIMARY KEY,
                  applied_at TIMESTAMPTZ DEFAULT NOW()
                );
              EOSQL

              # Migration 001: RLS Client and Storage Bucket
              # This sets up infrastructure that Kurrier needs to work with Supabase:
              # - The rls_client user for Row Level Security
              # - The attachments storage bucket
              # - Storage policies for user-owned file access
              if ! psql -tAc "SELECT 1 FROM migrations WHERE version = '001_rls_client'" | grep -q 1; then
                echo "Applying migration 001_rls_client..."
                psql -v ON_ERROR_STOP=1 <<-EOSQL
                  -- Create policy helper function
                  CREATE OR REPLACE FUNCTION public.__ensure_policy(p_name text, p_rel regclass, p_sql text)
                  RETURNS void LANGUAGE plpgsql AS \$\$
                  BEGIN
                    IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = p_name AND polrelid = p_rel) THEN
                      EXECUTE p_sql;
                    END IF;
                  END\$\$;

                  -- Create RLS client user if not exists
                  DO \$\$
                  BEGIN
                    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'rls_client') THEN
                      CREATE USER rls_client
                        WITH LOGIN PASSWORD '${RLS_CLIENT_PASSWORD}'
                        NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT;
                      GRANT anon TO rls_client;
                      GRANT authenticated TO rls_client;
                    END IF;
                  END \$\$;

                  -- Create attachments bucket if not exists
                  INSERT INTO storage.buckets (id, name, public)
                  VALUES ('attachments', 'attachments', false)
                  ON CONFLICT (id) DO NOTHING;

                  -- Storage RLS policies
                  SELECT public.__ensure_policy(
                    'private-own-crud',
                    'storage.objects'::regclass,
                    \$policy\$
                      CREATE POLICY "private-own-crud" ON storage.objects
                      FOR ALL TO authenticated
                      USING (bucket_id = 'attachments' AND (storage.foldername(name))[1] = 'private' AND (storage.foldername(name))[2] = auth.uid()::text)
                      WITH CHECK (bucket_id = 'attachments' AND (storage.foldername(name))[1] = 'private' AND (storage.foldername(name))[2] = auth.uid()::text)
                    \$policy\$
                  );

                  SELECT public.__ensure_policy(
                    'eml-own-crud',
                    'storage.objects'::regclass,
                    \$policy\$
                      CREATE POLICY "eml-own-crud" ON storage.objects
                      FOR ALL TO authenticated
                      USING (bucket_id = 'attachments' AND (storage.foldername(name))[1] = 'eml' AND (storage.foldername(name))[2] = auth.uid()::text)
                      WITH CHECK (bucket_id = 'attachments' AND (storage.foldername(name))[1] = 'eml' AND (storage.foldername(name))[2] = auth.uid()::text)
                    \$policy\$
                  );

                  -- Record migration
                  INSERT INTO migrations (version) VALUES ('001_rls_client');
              EOSQL
                echo "Migration 001_rls_client applied."
              else
                echo "Migration 001_rls_client already applied, skipping."
              fi

              # Note: Additional migrations for Kurrier application tables (providers, smtp_accounts,
              # mail_rules, etc.) are handled by the Kurrier application itself via Drizzle ORM.
              # This job only sets up the Supabase infrastructure prerequisites.

              echo "All migrations complete!"
{{- end }}
